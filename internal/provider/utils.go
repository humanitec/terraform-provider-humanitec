package provider

import (
	"bytes"
	"encoding/json"
	"errors"
	"maps"
	"os"

	"github.com/hashicorp/terraform-plugin-framework/diag"
	"sigs.k8s.io/yaml"
)

type Config struct {
	ApiPrefix string `yaml:"apiPrefix,omitempty"`
	Org       string `yaml:"org,omitempty"`
	Token     string `yaml:"token,omitempty"`
}

func valueAtPath[T any](input map[string]interface{}, path []string) (T, bool) {
	lenPath := len(path)

	var v T
	var ok bool

	for i := 0; i < lenPath; i++ {
		elem := input[path[i]]
		if i+1 == lenPath {
			v, ok = elem.(T)
			return v, ok
		}

		input, ok = elem.(map[string]interface{})
		if !ok {
			return v, ok
		}
	}

	return v, ok
}

func findInSlicePtr[T any](in *[]T, f func(T) bool) (T, bool) {
	found := false
	var element T

	if in == nil {
		return element, found
	}

	for _, e := range *in {
		if f(e) {
			found = true
			element = e
			break
		}
	}

	return element, found
}

func readConfig(data HumanitecProviderModel) (config Config, diags diag.Diagnostics) {
	diags = diag.Diagnostics{}
	// Check for .humctl file generated by humctl command line tool
	configFilePath := data.Config.ValueString()
	if configFilePath == "" {
		homeDir, err := os.UserHomeDir()
		if err != nil {
			diags.AddWarning(
				"Unable to determine home directory",
				"While configuring the provider, terraform was unable "+
					"to determine user's home directory to read config file.",
			)
			configFilePath = ""
		} else {
			configFilePath = homeDir + "/.humctl"
			if _, err := os.Stat(configFilePath); errors.Is(err, os.ErrNotExist) {
				configFilePath = ""
			}
		}
	} else if _, err := os.Stat(configFilePath); errors.Is(err, os.ErrNotExist) {
		diags.AddError(
			"Unable to read config file",
			"Terraform was unable to read config file mentioned "+
				"in the config attribute.",
		)
		return
	}

	if configFilePath == "" {
		return
	}

	file, err := os.ReadFile(configFilePath)
	if err != nil {
		diags.AddError(
			"Unable to read config file",
			"Terraform was unable to read the yaml config file "+
				"in "+configFilePath,
		)
		return
	}

	err = yaml.Unmarshal(file, &config)
	if err != nil {
		diags.AddError(
			"Unable to parse yaml from config file",
			"Terraform was unable to parse yaml config  "+
				"file in "+configFilePath,
		)
		return
	}
	return
}

func toPtr[T any](value T) *T {
	return &value
}

// strictUnmarshal unmarshals the JSON data into the provided value and returns an error if the data contains unknown fields.
func strictUnmarshal(data []byte, v interface{}) error {
	dec := json.NewDecoder(bytes.NewReader(data))
	dec.DisallowUnknownFields()
	return dec.Decode(v)
}

// overrideMap overrides the base map with the values from the override map.
func overrideMap[M ~map[K]V, K comparable, V any](base M, override M) {
	maps.DeleteFunc(base, func(K K, V V) bool {
		_, ok := override[K]
		return !ok
	})
	maps.Copy(base, override)
}
